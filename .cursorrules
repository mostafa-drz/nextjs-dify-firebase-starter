# Cursor Rules for Dify Firebase Boilerplate

## ğŸ”’ CRITICAL SECURITY RULES

### API Key Security

- **NEVER** use `NEXT_PUBLIC_` prefix for sensitive API keys (Dify, OpenAI, etc.)
- **ALWAYS** use server actions for sensitive API operations
- **NEVER** instantiate services with sensitive API keys on client-side
- **ALWAYS** validate that sensitive operations go through server-side only

### Sensitive API Keys Pattern

When working with sensitive API keys:

1. **Server-side only**: Use `process.env.API_KEY` (no NEXT*PUBLIC* prefix)
2. **Client-side**: Create server actions in `src/lib/actions/`
3. **Hooks**: Call server actions, never direct API calls
4. **Validation**: Ensure environment validation doesn't expect client-side sensitive keys

### Forbidden Patterns

```typescript
// âŒ NEVER DO THIS - Exposes API key to client
const service = new SomeService({
  apiKey: process.env.NEXT_PUBLIC_DIFY_API_KEY,
});

// âŒ NEVER DO THIS - Client-side API calls
const response = await fetch('/api/external', {
  headers: { Authorization: `Bearer ${process.env.NEXT_PUBLIC_API_KEY}` },
});
// âŒ NEVER DO THIS - Sensitive keys in client components
('use client');
const apiKey = process.env.NEXT_PUBLIC_SENSITIVE_KEY;
```

### Required Patterns

```typescript
// âœ… DO THIS - Server actions for sensitive operations
'use server';
export async function sensitiveOperation() {
  const apiKey = process.env.SENSITIVE_API_KEY; // Server-side only
  // ... implementation
}

// âœ… DO THIS - Client hooks call server actions
('use client');
export function useSensitiveOperation() {
  const mutation = useMutation({
    mutationFn: async data => {
      return await sensitiveOperation(data); // Server action
    },
  });
}
```

## ğŸ—ï¸ Architecture Rules

### Next.js 15 Server/Client Component Separation

**CRITICAL**: Never mix server and client functionality in the same component or layout.

#### Server Components (Default)

- **Run on**: Server during SSR/SSG
- **Access**: All environment variables (`process.env.*`)
- **Cannot use**: `useState`, `useEffect`, event handlers, browser APIs
- **Use for**: Data fetching, server-side logic, sensitive operations
- **Marking**: No directive needed (default)

#### Client Components

- **Run on**: Browser after hydration
- **Access**: Only `NEXT_PUBLIC_*` environment variables
- **Can use**: `useState`, `useEffect`, event handlers, browser APIs
- **Use for**: Interactivity, UI state, client-side logic
- **Marking**: Must have `'use client'` directive at top

#### Strict Separation Rules

```typescript
// âœ… CORRECT - Server Component (no directive)
export default function ServerComponent() {
  // Can access all env vars
  const apiKey = process.env.DIFY_API_KEY;
  // Can do data fetching
  const data = await fetchData();
  return <div>{data}</div>;
}

// âœ… CORRECT - Client Component
'use client';
export default function ClientComponent() {
  // Can only access NEXT_PUBLIC_ vars
  const publicKey = process.env.NEXT_PUBLIC_FIREBASE_API_KEY;
  // Can use hooks
  const [state, setState] = useState();
  return <button onClick={() => setState('clicked')}>Click</button>;
}
```

#### Forbidden Patterns

```typescript
// âŒ NEVER DO THIS - Server component accessing client-only vars
export default function BadServerComponent() {
  // This will be undefined on server!
  const clientVar = process.env.NEXT_PUBLIC_SOMETHING;
  return <div>{clientVar}</div>;
}

// âŒ NEVER DO THIS - Client component accessing server-only vars
'use client';
export default function BadClientComponent() {
  // This will be undefined in browser!
  const serverVar = process.env.DIFY_API_KEY;
  return <div>{serverVar}</div>;
}

// âŒ NEVER DO THIS - Mixed functionality
export default function BadMixedComponent() {
  const serverData = process.env.SERVER_VAR; // Server-only
  return (
    <div>
      {serverData}
      <button onClick={() => {}}>Click</button> {/* Client-only */}
    </div>
  );
}
```

#### Layout Architecture Rules

```typescript
// âœ… CORRECT - Server Layout with Client Providers
export default function ServerLayout({ children }) {
  return (
    <html>
      <body>
        {/* Server-side components */}
        <ServerHeader />

        {/* Client-side providers */}
        <ClientProviders>
          {children}
        </ClientProviders>
      </body>
    </html>
  );
}

// âœ… CORRECT - Client Providers Component
'use client';
export function ClientProviders({ children }) {
  return (
    <QueryProvider>
      <AuthProvider>
        <EnvValidation /> {/* Client-side validation */}
        {children}
      </AuthProvider>
    </QueryProvider>
  );
}
```

### Server/Client Separation

- **Server Components**: Use for data fetching, sensitive operations
- **Client Components**: Use for interactivity, UI state
- **Server Actions**: Use for all external API calls with sensitive keys
- **API Routes**: Use for complex server-side logic

### Firebase Client-Side Operations Priority

**ALWAYS prefer Firebase client-side operations over server-side API calls when possible:**

#### âœ… Use Firebase Client-Side Operations For:

- **User data operations** (profile updates, preferences, settings)
- **Real-time data** (chat messages, live updates, notifications)
- **Offline support** (Firestore provides built-in offline capabilities)
- **User authentication** (Firebase Auth handles this securely)
- **File uploads** (Firebase Storage with security rules)
- **Simple CRUD operations** on user-owned data

#### âŒ Use Server Actions Only For:

- **External API calls** (Dify, OpenAI, third-party services)
- **Sensitive operations** (payment processing, admin functions)
- **Complex business logic** (credit calculations, data validation)
- **Operations requiring server-side secrets** (API keys, private keys)

#### Why Firebase Client-Side Operations?

1. **Security**: Firebase Security Rules handle authorization
2. **Real-time**: Built-in real-time updates and offline support
3. **Performance**: Direct client-to-Firebase connection (faster)
4. **Maintainability**: Less server-side code to maintain
5. **Scalability**: Firebase handles scaling automatically
6. **Privacy**: User data stays within Firebase's secure infrastructure

#### Firebase Architecture Pattern:

```typescript
// âœ… DO THIS - Firebase client-side operations
'use client';
import { doc, updateDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase/client';

export function useUserProfile() {
  const updateProfile = async (userId: string, data: any) => {
    // Direct Firestore operation - secure via security rules
    await updateDoc(doc(db, 'users', userId), data);
  };
}

// âŒ AVOID THIS - Unnecessary server-side API call
('use client');
export function useUserProfile() {
  const updateProfile = async (userId: string, data: any) => {
    // Unnecessary round-trip through server
    await fetch('/api/users/update', {
      method: 'POST',
      body: JSON.stringify({ userId, data }),
    });
  };
}
```

### Firebase Security Rules Strategy

**Firebase Security Rules are your primary security mechanism for client-side operations:**

#### Security Rules Best Practices:

```javascript
// âœ… Comprehensive Firestore security rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only access their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Chat messages - users can read/write their own conversations
    match /conversations/{conversationId} {
      allow read, write: if request.auth != null &&
        request.auth.uid in resource.data.participants;
    }
  }
}
```

#### Decision Matrix: Client-Side vs Server-Side

| Operation              | Use Client-Side | Use Server-Side | Reason                                |
| ---------------------- | --------------- | --------------- | ------------------------------------- |
| User profile update    | âœ…              | âŒ              | Direct Firestore with security rules  |
| Chat message send      | âœ…              | âŒ              | Real-time, offline support            |
| File upload to Storage | âœ…              | âŒ              | Firebase Storage with security rules  |
| Credit deduction       | âŒ              | âœ…              | Business logic, requires validation   |
| External API call      | âŒ              | âœ…              | Requires server-side API keys         |
| Admin operations       | âŒ              | âœ…              | Sensitive, requires server validation |

### Environment Variables

- **Client-safe**: `NEXT_PUBLIC_*` (Firebase config, public URLs)
- **Server-only**: `API_KEY`, `SECRET`, `PRIVATE_KEY`, `TOKEN`
- **Validation**: Check `src/lib/config/env-validation.ts` for required vars

#### Environment Validation Patterns

```typescript
// âœ… CORRECT - Server-side validation
export function validateServerEnv(): void {
  const serverVars = ['DIFY_API_KEY', 'FIREBASE_PRIVATE_KEY'];
  for (const varName of serverVars) {
    if (!process.env[varName]) {
      throw new Error(`Missing server env var: ${varName}`);
    }
  }
}

// âœ… CORRECT - Client-side validation
('use client');
export function validateClientEnv(): void {
  const clientVars = ['NEXT_PUBLIC_FIREBASE_API_KEY'];
  for (const varName of clientVars) {
    if (!process.env[varName]) {
      throw new Error(`Missing client env var: ${varName}`);
    }
  }
}

// âŒ NEVER DO THIS - Mixed validation
export function validateMixedEnv(): void {
  // This will fail on server!
  const clientVar = process.env.NEXT_PUBLIC_SOMETHING;
  // This will fail on client!
  const serverVar = process.env.DIFY_API_KEY;
}
```

## ğŸ§ª Testing Rules

### Security Testing

- **Always test**: That sensitive API keys are not exposed in browser
- **Check**: Network tab for any client-side API calls with sensitive keys
- **Verify**: Environment variables are properly scoped

### Test-Driven Development (TDD) for Bug Fixes

**When a bug is reported, follow TDD approach when possible:**

#### TDD Bug Fix Process:

1. **Write a failing test** that reproduces the bug
2. **Run the test** - it should fail (red)
3. **Fix the bug** to make the test pass (green)
4. **Refactor** if needed while keeping tests green

#### TDD Benefits for Bug Fixes:

- **Prevents regression**: Test ensures bug doesn't come back
- **Clear reproduction**: Test documents exactly what was broken
- **Confidence**: You know the fix actually works
- **Documentation**: Test serves as living documentation of the bug

#### TDD Bug Fix Example:

```typescript
// 1. Write failing test first
describe('Bug Fix: User profile not updating', () => {
  it('should update user profile when valid data is provided', async () => {
    // Arrange
    const userId = 'test-user-123';
    const profileData = { name: 'John Doe', email: 'john@example.com' };

    // Act
    const result = await updateUserProfile(userId, profileData);

    // Assert - This should fail initially (red)
    expect(result.success).toBe(true);
    expect(result.data.name).toBe('John Doe');
  });
});

// 2. Run test - it fails (red)
// 3. Fix the bug in updateUserProfile function
// 4. Run test again - it passes (green)
```

#### When to Use TDD for Bugs:

- âœ… **Use TDD when**: Bug is reproducible, has clear input/output, affects core functionality
- âŒ **Skip TDD when**: Bug is complex to reproduce, involves UI/UX issues, is a one-off edge case
- âš ï¸ **Time limit**: Don't spend more than 30 minutes writing tests for simple bugs

#### TDD Guidelines:

- **Start simple**: Write the most basic test that reproduces the bug
- **Focus on behavior**: Test what the code should do, not implementation details
- **Keep tests fast**: Use mocks and stubs for external dependencies
- **One test per bug**: Don't over-test, focus on the specific issue

### Testing Framework: Vitest (NOT Jest)

**CRITICAL**: This project uses **Vitest**, not Jest. Always use Vitest syntax.

#### Vitest vs Jest Differences:

```typescript
// âœ… CORRECT - Vitest syntax
import { vi } from 'vitest';

// Mock modules
vi.mock('@/lib/some-module', () => ({
  someFunction: vi.fn(),
}));

// Mock functions
const mockFn = vi.fn();
mockFn.mockReturnValue('test');

// Clear mocks
vi.clearAllMocks();

// Test environment
/**
 * @vitest-environment jsdom
 */
```

```typescript
// âŒ NEVER DO THIS - Jest syntax (will fail)
import { jest } from '@jest/globals'; // This doesn't exist!

// Mock modules
jest.mock('@/lib/some-module', () => ({
  someFunction: jest.fn(), // ReferenceError: jest is not defined
}));

// Mock functions
const mockFn = jest.fn(); // ReferenceError: jest is not defined
```

#### Vitest Testing Patterns:

```typescript
// âœ… Test server actions
test('server action uses server-side API key', async () => {
  const result = await serverAction();
  expect(result.success).toBe(true);
});

// âœ… Test client hooks don't expose keys
test('client hook calls server action', () => {
  const { result } = renderHook(() => useClientHook());
  expect(result.current.callServerAction).toBeDefined();
});

// âœ… Test bug reproduction
test('reproduces reported bug: user cannot update profile', async () => {
  const user = { id: 'user-123', name: 'John' };
  const updateData = { name: 'John Doe' };

  const result = await updateUserProfile(user.id, updateData);

  expect(result.success).toBe(true);
  expect(result.data.name).toBe('John Doe');
});

// âœ… Component testing with mocks
import { vi } from 'vitest';

vi.mock('@/components/SomeComponent', () => ({
  SomeComponent: () => <div data-testid="mocked-component">Mocked</div>,
}));

test('renders component with mocked dependency', () => {
  render(<ParentComponent />);
  expect(screen.getByTestId('mocked-component')).toBeInTheDocument();
});
```

#### Common Vitest Commands:

```bash
# Run all tests
npm test

# Run specific test file
npm test ComponentName

# Run tests in watch mode
npm test -- --watch

# Run tests with coverage
npm test -- --coverage
```

## ğŸ“ File Organization

### Server Actions

- **Location**: `src/lib/actions/`
- **Pattern**: `[service]-[operation].ts`
- **Example**: `dify-chat.ts`, `dify-files.ts`

### Client Hooks

- **Location**: `src/lib/hooks/`
- **Pattern**: Call server actions, never direct API calls
- **Example**: `useStreamingChat.ts`, `useFileUpload.ts`

## ğŸš¨ Security Checklist

Before committing code with API keys:

- [ ] No `NEXT_PUBLIC_` prefix on sensitive keys
- [ ] All sensitive operations use server actions
- [ ] Client hooks call server actions only
- [ ] Environment validation is correct
- [ ] No direct API calls from client components
- [ ] Sensitive keys are server-side only
- [ ] Firebase operations use client-side when appropriate
- [ ] Firestore security rules are properly configured
- [ ] User data operations leverage Firebase client-side
- [ ] External API calls go through server actions only

## ğŸ› Bug Fix Checklist

When fixing bugs:

- [ ] **TDD Approach**: Write failing test first (when possible)
- [ ] **Reproduce**: Test clearly reproduces the reported bug
- [ ] **Fix**: Implement fix to make test pass
- [ ] **Verify**: Test passes and bug is resolved
- [ ] **Time limit**: Don't spend more than 30 minutes on test writing
- [ ] **Focus**: One test per bug, keep it simple
- [ ] **Documentation**: Test serves as living documentation

## ğŸ” Code Review Focus

When reviewing code:

1. **Check imports**: Look for client-side service instantiation
2. **Check environment**: Verify no sensitive keys with NEXT*PUBLIC*
3. **Check patterns**: Ensure server actions for sensitive operations
4. **Check hooks**: Verify they call server actions, not direct API calls

## ğŸ“š Examples

### âœ… Correct Implementation

```typescript
// Server action (src/lib/actions/dify-chat.ts)
'use server';
export async function sendChatMessage(userId: string, message: string) {
  const apiKey = process.env.DIFY_API_KEY; // Server-side only
  // ... implementation
}

// Client hook (src/lib/hooks/useChat.ts)
('use client');
export function useChat() {
  const sendMessage = useMutation({
    mutationFn: async message => {
      return await sendChatMessage(userId, message); // Server action
    },
  });
}
```

### âŒ Incorrect Implementation

```typescript
// Client component - NEVER DO THIS
'use client';
export function ChatComponent() {
  const service = new DifyService({
    apiKey: process.env.NEXT_PUBLIC_DIFY_API_KEY, // EXPOSES KEY!
  });
}
```

## ğŸ¯ Firebase Architecture Benefits

### Why Leverage Firebase Client-Side Operations?

1. **ğŸ”’ Security by Design**: Firebase Security Rules provide fine-grained access control
2. **âš¡ Performance**: Direct client-to-Firebase connection eliminates server round-trips
3. **ğŸ”„ Real-time**: Built-in real-time updates and offline support
4. **ğŸ“± Offline First**: Firestore handles offline scenarios automatically
5. **ğŸ› ï¸ Maintainability**: Less server-side code to maintain and debug
6. **ğŸ“ˆ Scalability**: Firebase handles scaling automatically
7. **ğŸ” Privacy**: User data stays within Firebase's secure infrastructure
8. **ğŸ’° Cost Efficiency**: Fewer server resources needed for simple operations

### Architecture Decision Tree:

```
Is it user data operation?
â”œâ”€ YES â†’ Use Firebase client-side operations
â”‚   â”œâ”€ Profile updates âœ…
â”‚   â”œâ”€ Preferences âœ…
â”‚   â”œâ”€ Chat messages âœ…
â”‚   â””â”€ File uploads âœ…
â””â”€ NO â†’ Does it require external API keys?
    â”œâ”€ YES â†’ Use server actions
    â”‚   â”œâ”€ Dify API calls âœ…
    â”‚   â”œâ”€ Payment processing âœ…
    â”‚   â””â”€ Admin operations âœ…
    â””â”€ NO â†’ Does it involve complex business logic?
        â”œâ”€ YES â†’ Use server actions
        â””â”€ NO â†’ Use Firebase client-side operations
```

Remember: **When in doubt, use server actions for sensitive operations, but prefer Firebase client-side for user data operations!**

## ğŸš« Proactive Code Changes Policy

**CRITICAL**: Never make proactive code changes, additions, or modifications without explicit user confirmation.

### Rules:

- **Ask First**: Always ask for permission before adding any code, content, or making changes
- **Keep Codebase Lean**: Avoid unnecessary additions that bloat the codebase
- **Conversation vs Action**: User may chat without intention of adding code or making changes
- **Wait for Confirmation**: Only proceed with code changes after explicit user approval

### When to Ask Permission:

- Adding new files or components
- Modifying existing code
- Adding debugging code or console logs
- Creating tests or documentation
- Making any codebase changes

### When NOT to Make Changes:

- During general discussion or analysis
- When user is just explaining a problem
- When user hasn't explicitly requested code changes
- During brainstorming or planning phases

**Remember**: Keep the codebase lean and only add what's explicitly requested and confirmed!
