# Cursor Rules for Dify Firebase Boilerplate

## üîí CRITICAL SECURITY RULES

### API Key Security

- **NEVER** use `NEXT_PUBLIC_` prefix for sensitive API keys (Dify, OpenAI, etc.)
- **ALWAYS** use server actions for sensitive API operations
- **NEVER** instantiate services with sensitive API keys on client-side
- **ALWAYS** validate that sensitive operations go through server-side only

### Sensitive API Keys Pattern

When working with sensitive API keys:

1. **Server-side only**: Use `process.env.API_KEY` (no NEXT*PUBLIC* prefix)
2. **Client-side**: Create server actions in `src/lib/actions/`
3. **Hooks**: Call server actions, never direct API calls
4. **Validation**: Ensure environment validation doesn't expect client-side sensitive keys

### Forbidden Patterns

```typescript
// ‚ùå NEVER DO THIS - Exposes API key to client
const service = new SomeService({
  apiKey: process.env.NEXT_PUBLIC_DIFY_API_KEY,
});

// ‚ùå NEVER DO THIS - Client-side API calls
const response = await fetch('/api/external', {
  headers: { Authorization: `Bearer ${process.env.NEXT_PUBLIC_API_KEY}` },
});
// ‚ùå NEVER DO THIS - Sensitive keys in client components
('use client');
const apiKey = process.env.NEXT_PUBLIC_SENSITIVE_KEY;
```

### Required Patterns

```typescript
// ‚úÖ DO THIS - Server actions for sensitive operations
'use server';
export async function sensitiveOperation() {
  const apiKey = process.env.SENSITIVE_API_KEY; // Server-side only
  // ... implementation
}

// ‚úÖ DO THIS - Client hooks call server actions
('use client');
export function useSensitiveOperation() {
  const mutation = useMutation({
    mutationFn: async data => {
      return await sensitiveOperation(data); // Server action
    },
  });
}
```

## üèóÔ∏è Architecture Rules

### Next.js 15 Server/Client Component Separation

**CRITICAL**: Never mix server and client functionality in the same component or layout.

#### Server Components (Default)

- **Run on**: Server during SSR/SSG
- **Access**: All environment variables (`process.env.*`)
- **Cannot use**: `useState`, `useEffect`, event handlers, browser APIs
- **Use for**: Data fetching, server-side logic, sensitive operations
- **Marking**: No directive needed (default)

#### Client Components

- **Run on**: Browser after hydration
- **Access**: Only `NEXT_PUBLIC_*` environment variables
- **Can use**: `useState`, `useEffect`, event handlers, browser APIs
- **Use for**: Interactivity, UI state, client-side logic
- **Marking**: Must have `'use client'` directive at top

#### Strict Separation Rules

```typescript
// ‚úÖ CORRECT - Server Component (no directive)
export default function ServerComponent() {
  // Can access all env vars
  const apiKey = process.env.DIFY_API_KEY;
  // Can do data fetching
  const data = await fetchData();
  return <div>{data}</div>;
}

// ‚úÖ CORRECT - Client Component
'use client';
export default function ClientComponent() {
  // Can only access NEXT_PUBLIC_ vars
  const publicKey = process.env.NEXT_PUBLIC_FIREBASE_API_KEY;
  // Can use hooks
  const [state, setState] = useState();
  return <button onClick={() => setState('clicked')}>Click</button>;
}
```

#### Forbidden Patterns

```typescript
// ‚ùå NEVER DO THIS - Server component accessing client-only vars
export default function BadServerComponent() {
  // This will be undefined on server!
  const clientVar = process.env.NEXT_PUBLIC_SOMETHING;
  return <div>{clientVar}</div>;
}

// ‚ùå NEVER DO THIS - Client component accessing server-only vars
'use client';
export default function BadClientComponent() {
  // This will be undefined in browser!
  const serverVar = process.env.DIFY_API_KEY;
  return <div>{serverVar}</div>;
}

// ‚ùå NEVER DO THIS - Mixed functionality
export default function BadMixedComponent() {
  const serverData = process.env.SERVER_VAR; // Server-only
  return (
    <div>
      {serverData}
      <button onClick={() => {}}>Click</button> {/* Client-only */}
    </div>
  );
}
```

#### Layout Architecture Rules

```typescript
// ‚úÖ CORRECT - Server Layout with Client Providers
export default function ServerLayout({ children }) {
  return (
    <html>
      <body>
        {/* Server-side components */}
        <ServerHeader />

        {/* Client-side providers */}
        <ClientProviders>
          {children}
        </ClientProviders>
      </body>
    </html>
  );
}

// ‚úÖ CORRECT - Client Providers Component
'use client';
export function ClientProviders({ children }) {
  return (
    <QueryProvider>
      <AuthProvider>
        <EnvValidation /> {/* Client-side validation */}
        {children}
      </AuthProvider>
    </QueryProvider>
  );
}
```

### Server/Client Separation

- **Server Components**: Use for data fetching, sensitive operations
- **Client Components**: Use for interactivity, UI state
- **Server Actions**: Use for all external API calls with sensitive keys
- **API Routes**: Use for complex server-side logic

### Firebase Client-Side Operations Priority

**ALWAYS prefer Firebase client-side operations over server-side API calls when possible:**

#### ‚úÖ Use Firebase Client-Side Operations For:

- **User data operations** (profile updates, preferences, settings)
- **Real-time data** (chat messages, live updates, notifications)
- **Offline support** (Firestore provides built-in offline capabilities)
- **User authentication** (Firebase Auth handles this securely)
- **File uploads** (Firebase Storage with security rules)
- **Simple CRUD operations** on user-owned data

#### ‚ùå Use Server Actions Only For:

- **External API calls** (Dify, OpenAI, third-party services)
- **Sensitive operations** (payment processing, admin functions)
- **Complex business logic** (credit calculations, data validation)
- **Operations requiring server-side secrets** (API keys, private keys)

#### Why Firebase Client-Side Operations?

1. **Security**: Firebase Security Rules handle authorization
2. **Real-time**: Built-in real-time updates and offline support
3. **Performance**: Direct client-to-Firebase connection (faster)
4. **Maintainability**: Less server-side code to maintain
5. **Scalability**: Firebase handles scaling automatically
6. **Privacy**: User data stays within Firebase's secure infrastructure

#### Firebase Architecture Pattern:

```typescript
// ‚úÖ DO THIS - Firebase client-side operations
'use client';
import { doc, updateDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase/client';

export function useUserProfile() {
  const updateProfile = async (userId: string, data: any) => {
    // Direct Firestore operation - secure via security rules
    await updateDoc(doc(db, 'users', userId), data);
  };
}

// ‚ùå AVOID THIS - Unnecessary server-side API call
('use client');
export function useUserProfile() {
  const updateProfile = async (userId: string, data: any) => {
    // Unnecessary round-trip through server
    await fetch('/api/users/update', {
      method: 'POST',
      body: JSON.stringify({ userId, data }),
    });
  };
}
```

### Firebase Security Rules Strategy

**Firebase Security Rules are your primary security mechanism for client-side operations:**

#### Security Rules Best Practices:

```javascript
// ‚úÖ Comprehensive Firestore security rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only access their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Chat messages - users can read/write their own conversations
    match /conversations/{conversationId} {
      allow read, write: if request.auth != null &&
        request.auth.uid in resource.data.participants;
    }
  }
}
```

#### Decision Matrix: Client-Side vs Server-Side

| Operation              | Use Client-Side | Use Server-Side | Reason                                |
| ---------------------- | --------------- | --------------- | ------------------------------------- |
| User profile update    | ‚úÖ              | ‚ùå              | Direct Firestore with security rules  |
| Chat message send      | ‚úÖ              | ‚ùå              | Real-time, offline support            |
| File upload to Storage | ‚úÖ              | ‚ùå              | Firebase Storage with security rules  |
| Credit deduction       | ‚ùå              | ‚úÖ              | Business logic, requires validation   |
| External API call      | ‚ùå              | ‚úÖ              | Requires server-side API keys         |
| Admin operations       | ‚ùå              | ‚úÖ              | Sensitive, requires server validation |

### Environment Variables

- **Client-safe**: `NEXT_PUBLIC_*` (Firebase config, public URLs)
- **Server-only**: `API_KEY`, `SECRET`, `PRIVATE_KEY`, `TOKEN`
- **Validation**: Check `src/lib/config/env-validation.ts` for required vars

#### Environment Validation Patterns

```typescript
// ‚úÖ CORRECT - Server-side validation
export function validateServerEnv(): void {
  const serverVars = ['DIFY_API_KEY', 'FIREBASE_PRIVATE_KEY'];
  for (const varName of serverVars) {
    if (!process.env[varName]) {
      throw new Error(`Missing server env var: ${varName}`);
    }
  }
}

// ‚úÖ CORRECT - Client-side validation
('use client');
export function validateClientEnv(): void {
  const clientVars = ['NEXT_PUBLIC_FIREBASE_API_KEY'];
  for (const varName of clientVars) {
    if (!process.env[varName]) {
      throw new Error(`Missing client env var: ${varName}`);
    }
  }
}

// ‚ùå NEVER DO THIS - Mixed validation
export function validateMixedEnv(): void {
  // This will fail on server!
  const clientVar = process.env.NEXT_PUBLIC_SOMETHING;
  // This will fail on client!
  const serverVar = process.env.DIFY_API_KEY;
}
```

## üß™ Testing Rules

### Security Testing

- **Always test**: That sensitive API keys are not exposed in browser
- **Check**: Network tab for any client-side API calls with sensitive keys
- **Verify**: Environment variables are properly scoped

### Test-Driven Development (TDD) for Bug Fixes

**When a bug is reported, follow TDD approach when possible:**

#### TDD Bug Fix Process:

1. **Write a failing test** that reproduces the bug
2. **Run the test** - it should fail (red)
3. **Fix the bug** to make the test pass (green)
4. **Refactor** if needed while keeping tests green

#### TDD Benefits for Bug Fixes:

- **Prevents regression**: Test ensures bug doesn't come back
- **Clear reproduction**: Test documents exactly what was broken
- **Confidence**: You know the fix actually works
- **Documentation**: Test serves as living documentation of the bug

#### TDD Bug Fix Example:

```typescript
// 1. Write failing test first
describe('Bug Fix: User profile not updating', () => {
  it('should update user profile when valid data is provided', async () => {
    // Arrange
    const userId = 'test-user-123';
    const profileData = { name: 'John Doe', email: 'john@example.com' };

    // Act
    const result = await updateUserProfile(userId, profileData);

    // Assert - This should fail initially (red)
    expect(result.success).toBe(true);
    expect(result.data.name).toBe('John Doe');
  });
});

// 2. Run test - it fails (red)
// 3. Fix the bug in updateUserProfile function
// 4. Run test again - it passes (green)
```

#### When to Use TDD for Bugs:

- ‚úÖ **Use TDD when**: Bug is reproducible, has clear input/output, affects core functionality
- ‚ùå **Skip TDD when**: Bug is complex to reproduce, involves UI/UX issues, is a one-off edge case
- ‚ö†Ô∏è **Time limit**: Don't spend more than 30 minutes writing tests for simple bugs

#### TDD Guidelines:

- **Start simple**: Write the most basic test that reproduces the bug
- **Focus on behavior**: Test what the code should do, not implementation details
- **Keep tests fast**: Use mocks and stubs for external dependencies
- **One test per bug**: Don't over-test, focus on the specific issue

### Testing Framework: Vitest (NOT Jest)

**CRITICAL**: This project uses **Vitest**, not Jest. Always use Vitest syntax.

#### Vitest vs Jest Differences:

```typescript
// ‚úÖ CORRECT - Vitest syntax
import { vi } from 'vitest';

// Mock modules
vi.mock('@/lib/some-module', () => ({
  someFunction: vi.fn(),
}));

// Mock functions
const mockFn = vi.fn();
mockFn.mockReturnValue('test');

// Clear mocks
vi.clearAllMocks();

// Test environment
/**
 * @vitest-environment jsdom
 */
```

```typescript
// ‚ùå NEVER DO THIS - Jest syntax (will fail)
import { jest } from '@jest/globals'; // This doesn't exist!

// Mock modules
jest.mock('@/lib/some-module', () => ({
  someFunction: jest.fn(), // ReferenceError: jest is not defined
}));

// Mock functions
const mockFn = jest.fn(); // ReferenceError: jest is not defined
```

#### Vitest Testing Patterns:

```typescript
// ‚úÖ Test server actions
test('server action uses server-side API key', async () => {
  const result = await serverAction();
  expect(result.success).toBe(true);
});

// ‚úÖ Test client hooks don't expose keys
test('client hook calls server action', () => {
  const { result } = renderHook(() => useClientHook());
  expect(result.current.callServerAction).toBeDefined();
});

// ‚úÖ Test bug reproduction
test('reproduces reported bug: user cannot update profile', async () => {
  const user = { id: 'user-123', name: 'John' };
  const updateData = { name: 'John Doe' };

  const result = await updateUserProfile(user.id, updateData);

  expect(result.success).toBe(true);
  expect(result.data.name).toBe('John Doe');
});

// ‚úÖ Component testing with mocks
import { vi } from 'vitest';

vi.mock('@/components/SomeComponent', () => ({
  SomeComponent: () => <div data-testid="mocked-component">Mocked</div>,
}));

test('renders component with mocked dependency', () => {
  render(<ParentComponent />);
  expect(screen.getByTestId('mocked-component')).toBeInTheDocument();
});
```

#### Common Vitest Commands:

```bash
# Run all tests
npm test

# Run specific test file
npm test ComponentName

# Run tests in watch mode
npm test -- --watch

# Run tests with coverage
npm test -- --coverage
```

## üìÅ File Organization

### Server Actions

- **Location**: `src/lib/actions/`
- **Pattern**: `[service]-[operation].ts`
- **Example**: `dify-chat.ts`, `dify-files.ts`

### Client Hooks

- **Location**: `src/lib/hooks/`
- **Pattern**: Call server actions, never direct API calls
- **Example**: `useStreamingChat.ts`, `useFileUpload.ts`

## üö® Security Checklist

Before committing code with API keys:

- [ ] No `NEXT_PUBLIC_` prefix on sensitive keys
- [ ] All sensitive operations use server actions
- [ ] Client hooks call server actions only
- [ ] Environment validation is correct
- [ ] No direct API calls from client components
- [ ] Sensitive keys are server-side only
- [ ] Firebase operations use client-side when appropriate
- [ ] Firestore security rules are properly configured
- [ ] User data operations leverage Firebase client-side
- [ ] External API calls go through server actions only

## üêõ Bug Fix Checklist

When fixing bugs:

- [ ] **TDD Approach**: Write failing test first (when possible)
- [ ] **Reproduce**: Test clearly reproduces the reported bug
- [ ] **Fix**: Implement fix to make test pass
- [ ] **Verify**: Test passes and bug is resolved
- [ ] **Time limit**: Don't spend more than 30 minutes on test writing
- [ ] **Focus**: One test per bug, keep it simple
- [ ] **Documentation**: Test serves as living documentation

## üîç Code Review Focus

When reviewing code:

1. **Check imports**: Look for client-side service instantiation
2. **Check environment**: Verify no sensitive keys with NEXT*PUBLIC*
3. **Check patterns**: Ensure server actions for sensitive operations
4. **Check hooks**: Verify they call server actions, not direct API calls

## üìö Examples

### ‚úÖ Correct Implementation

```typescript
// Server action (src/lib/actions/dify-chat.ts)
'use server';
export async function sendChatMessage(userId: string, message: string) {
  const apiKey = process.env.DIFY_API_KEY; // Server-side only
  // ... implementation
}

// Client hook (src/lib/hooks/useChat.ts)
('use client');
export function useChat() {
  const sendMessage = useMutation({
    mutationFn: async message => {
      return await sendChatMessage(userId, message); // Server action
    },
  });
}
```

### ‚ùå Incorrect Implementation

```typescript
// Client component - NEVER DO THIS
'use client';
export function ChatComponent() {
  const service = new DifyService({
    apiKey: process.env.NEXT_PUBLIC_DIFY_API_KEY, // EXPOSES KEY!
  });
}
```

## üéØ Firebase Architecture Benefits

### Why Leverage Firebase Client-Side Operations?

1. **üîí Security by Design**: Firebase Security Rules provide fine-grained access control
2. **‚ö° Performance**: Direct client-to-Firebase connection eliminates server round-trips
3. **üîÑ Real-time**: Built-in real-time updates and offline support
4. **üì± Offline First**: Firestore handles offline scenarios automatically
5. **üõ†Ô∏è Maintainability**: Less server-side code to maintain and debug
6. **üìà Scalability**: Firebase handles scaling automatically
7. **üîê Privacy**: User data stays within Firebase's secure infrastructure
8. **üí∞ Cost Efficiency**: Fewer server resources needed for simple operations

### Architecture Decision Tree:

```
Is it user data operation?
‚îú‚îÄ YES ‚Üí Use Firebase client-side operations
‚îÇ   ‚îú‚îÄ Profile updates ‚úÖ
‚îÇ   ‚îú‚îÄ Preferences ‚úÖ
‚îÇ   ‚îú‚îÄ Chat messages ‚úÖ
‚îÇ   ‚îî‚îÄ File uploads ‚úÖ
‚îî‚îÄ NO ‚Üí Does it require external API keys?
    ‚îú‚îÄ YES ‚Üí Use server actions
    ‚îÇ   ‚îú‚îÄ Dify API calls ‚úÖ
    ‚îÇ   ‚îú‚îÄ Payment processing ‚úÖ
    ‚îÇ   ‚îî‚îÄ Admin operations ‚úÖ
    ‚îî‚îÄ NO ‚Üí Does it involve complex business logic?
        ‚îú‚îÄ YES ‚Üí Use server actions
        ‚îî‚îÄ NO ‚Üí Use Firebase client-side operations
```

Remember: **When in doubt, use server actions for sensitive operations, but prefer Firebase client-side for user data operations!**

## üö´ Proactive Code Changes Policy

**CRITICAL**: Never make proactive code changes, additions, or modifications without explicit user confirmation.

### Rules:

- **Ask First**: Always ask for permission before adding any code, content, or making changes
- **Keep Codebase Lean**: Avoid unnecessary additions that bloat the codebase
- **Conversation vs Action**: User may chat without intention of adding code or making changes
- **Wait for Confirmation**: Only proceed with code changes after explicit user approval

### When to Ask Permission:

- Adding new files or components
- Modifying existing code
- Adding debugging code or console logs
- Creating tests or documentation
- Making any codebase changes

### When NOT to Make Changes:

- During general discussion or analysis
- When user is just explaining a problem
- When user hasn't explicitly requested code changes
- During brainstorming or planning phases

**Remember**: Keep the codebase lean and only add what's explicitly requested and confirmed!
